---
title: Creating an application
layout: tutorial
prev: 340-junit.html
next: 450-debug.html
summary: How to run your code in a framework
---
## What You Will Learn in This Section

All this work to get a working provider! However, we've only run it in a evaluation and test mode. In this section we will take a look how we can use this provider bundle in an application we can deploy.

There are a myriad of deploy formats in Java (and OSGi!): WAR files, Karaf CARs, EAR files, OSGi Subsystems, OSGi Deployment Admin, etc. Bndtools can support all of those through _plugins_ but always natively supports the most humblest of all deployment formats: an executable JAR. An executable JAR has no external dependencies, everything it needs outside the JDK is embedded.

The beauty of an executable JAR is that it can be started anywhere there is a java virtual machine:

	$ java -jar executable.jar

## Creating an Application

The first thing we need to do is create a `bndrun` file. A `bndrun` file is a separate file for the `bnd.bnd` `Run` tab. It allows us to specify a runtime for our framework. 

So do a `New/Bndtools OSGi Project` and use `com.acme.prime.eval.application` as the project name. The `.application` extension for this project creates an *application* project. Don't forget to use the OSGi enRoute templates! An application project should contain no code (or very little) but acts as a spear point. It contains the requirements that will drive the final application.

## The Sole Content

By default, an application only contains a Gogo shell command, in this case in the `EvalApplication` class. This one is very similar, and then not really, to the `EvalImpl` class. In the `EvalImpl` class we just made the existing API call, `eval`, available as a Gogo command. In this application project we need to get the service and call the method on that service. Getting a service is made very easy with DS, just add a setter method and add the `@Reference` annotation. So lets replace the code for  the `EvalApplication` code with:

	@Component(
		service=EvalApplication.class, 
		property = { 
			Debug.COMMAND_SCOPE + "=eval",
			Debug.COMMAND_FUNCTION + "=eval" 
		},
		name="com.acme.prime.eval"
	)
	public class EvalApplication {
		private Eval eval;
	
		public double eval(String m) throws Exception {
			return eval.eval(m);
		}
		
		@Reference
		void setEval( Eval eval) {
			this.eval= eval;
		}
	}

This code registers a dummy service that now provides the `eval:eval` command to Gogo shell.

Just like the test project, we need to add a dependency on the API project. As usual, go to the `Build` tab and add the `com.acme.prime.eval.api` project.

## Defining the Application

We will define the run time requirements in a special file, a `bndrun` file. Such a file is already placed in the application project: `com.acme.prime.eval.bndrun`. Such a `bndrun` file is basically the information we have been working with in the `bnd.bnd` `Run` tab. If you double click on it, then it should look like:

![Application bndrun](/img/tutorial_base/deploy-bndrun-0.png)

As you can see, the initial requirement for our Gogo command is already there. Before we try it out, let's add a shell (`org.apache.felix.gogo.shell`) so it is slightly more interactive. That's it! Hit the `Resolve` button and save the `bndrun` file. 

![Application bndrun](/img/tutorial_base/deploy-bndrun-1.png)

At the right top of the `bndrun`'s `Run` tab there are a number of buttons:

![Application bndrun](/img/tutorial_base/deploy-bndrun-2.png)

If you click the `Debug OSGi` button then bnd will launch a framework and run your application.

Since we have a shell, we can try out the command:

	g! eval:eval pi*13.36901521971921
	42.0

And it took considerably less time than 7.5 million years!

## Debugging

Let's first kill this framework so we can start another framework that is friendlier on the debugging side. Just click on the red button in the Eclipse console.

The application project also includes a `debug.bndrun` file. This is also a `bndrun` file but it adds debug requirements. So quit the running framework (Go to the console, and click on the red button) and double click the `debug.bndrun` file, resolve, and click `Debug OSGi`.

The first thing you'll notice is how the console is filled with red text. This is the trace output of the launcher. If things do not really work as you expected (never happens to us ...) then this output, which traces the installation process in fine detail, can help you solve the problems. This behavior is triggered by the -runtrace flag. Click on the `bnd.bnd` `Source` tab, and change it to false or remove it if you do not want this trace.

![Application bndrun](/img/tutorial_base/deploy-debug-0.png)

The `debug.bndrun` file inherits from the `com.acme.prime.eval.bndrun` file, any initial requirement we add to this file is automatically added to the debug run; first principle of Don't Repeat Yourself (DRY). However, the `debug.bndrun` adds a set of standard requirements that make it so much easier to debug OSGi applications. It adds Web Console, the Gogo shell, etc. So click on the `Debug OSGi` button and then go to [http://localhost:8080/system/console/xray](http://localhost:8080/system/console/xray) to inspect your OSGi system. The user id and password were `admin`, and ... drumroll ... `admin`.

![Application bndrun](/img/tutorial_base/deploy-debug-1.png)

XRay and its associated tools are explained in the [debug section](450-debug.html).

## Updating

Adding, subtracting, gets a bit boring after a while, didn't the bible tell us to multiply? So why not be nice and add multiplication and division. First open the provider project and change the implementation of eval as follows:

	Pattern EXPR = Pattern
			.compile("\\s*(?<left>\\d+)\\s*(?<op>\\+|-|\\*|/)\\s*(?<right>\\d+)\\s*");

	....
	
		switch (m.group("op")) {
		case "+":
			return left + right;
		case "-":
			return left - right;
		case "*":
			return left * right;
		case "/":
			return left / right;
		}

Just add the new code and save the `EvalImpl` class, then go to the Gogo shell. Hmm, you did not really have to stop the framework, in the OSGi world we are dynamic. So if you out of bad habit killed the running process you should first restart the framework. Click on the `bnd.bnd` file, select the `Run` tab and click the `Debug OSGi` button. If you don't understand what I am talking about your framework should still be humming along, having just been updated. So assuming we're all in the Gogo shell now:

	g! eval:eval 6*7
	42.0
{: .shell }

What happened? When we changed the source code, the IDE compiled the class, which triggered bnd to build the bundle. A changed bundle is detected by the launcher and automatically deployed to the running framework. This obviously required our bundle to be updated. In practice, you rarely have to restart the framework, everything you change in the IDE, including changes in the bnd.bnd file are quickly deployed to the running framework.

## How Does it Work?

When you launch an application a launcher is started in a remote process. This launcher gets a properties that describes what framework to use, what bundles to load etc. This properties file is created by bndtools. After the launcher has initialized everything, it starts the bundles and then starts watching the properties file. If this file changes, it reloads it and calculates a delta and then applies this delta to the running framework. This works for most of the information but not everything.

In the bndtools process we are listening to changes to any of the information that was used to created the properties file. If such a change is detected, the launch property file is recreated, thereby triggering the launcher.   

To develop in such a dynamic environment is actually good practice even if you run the system quite statically. The dynamism during development will point out a lot of potential issues and make your code much more robust. It is a bit like fighter pilots. They get trained at a 10% higher speed than reality, when they hit the dog fight they can feel quite zen because it is so much slower than what they're used to! 


[1]: http://felix.apache.org/site/apache-felix-gogo.html
